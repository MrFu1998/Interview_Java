## Java面试题

- 问题：如果`main`方法被声明为`private`会怎么样？

  - 答案：能正常编译，但运行的时候会提示" `main`方法不是`public`的"

- 问题：`Java`里的传引用和传值的区别是什么？

  - 答案：传引用是指传递的是地址而不是指本身，传值则是传递值的一份拷贝

- 问题：如果要重写一个对象的`equals`方法，还要考虑什么？

  - 答案：`hashCode`

- 问题：`Java`的“一次编码，处处运行”是如何实现的？

  - 答案：`Java`程序会被编译成字节码组成的`class`文件，这些字节码可以运行在任何平台，因此`Java`是平台独立的

- 问题：说明一下`public static void main(String[] args)`这段声明里每个关键字的作用？

  - 答案：
    - `public`:`main`方法是`Java`程序运行时调用的第一个方法，因此它必须对`Java`环境可见。所以可见性设置`public`
    - `static`:`Java`平台调用这个方法时不会创建这个类的一个实例，因此这个方法必须声明为`static`
    - `void`:`main方法没有返回值`
    - `String`是命令行传进参数的类型，`args`是指命令行传进的字符串数组

- 问题 ：`==` 与 `equals` 的区别

  - 答案：`==` 是比较两个对象在内存里是不是一个对象，就是说内存里的存储位置一致。两个`String`对象存储的值是一样的，但有可能在内存里存储在不同的地方，`==` 比较的是引用而`equals`方法比较的是内容。`public boolean equals(Object obj)`这个方法是有`Object`对象提供的，可以由子类进行重写。默认的实现只有当对象和自身进行比较时才会返回`true`，这个时候和`==` 是等价的。`String , BitSet ,Date`和`File`都对`equals`方法进行了重写。对两个`String`对象而言，值相等意味着他们包含同样的字符序列。对于基于类型的包装类来说，值相等意味着对应的基本类型的值一样，下面是代码示例：

  ```java
    public class EqualsTest{
      public static void main(String[] args){
        String s1 = "abc";
        String s2 = s1;
        String s3 = "abc";
        String s4 = new String("abc");
        String s5 = new String("abc");
          System.out.printIn("== comparison :" + （s1 == s3）);
        System.out.printIn("== comparison :" + （s1 == s2）);
        System.out.printIn("Using equals method :" + s1.equals(s2));
        System.out.printIn("== comparison :" + （s4 == s5）);
        System.out.printIn("Using equals method :" + s3.equals(s4)); 

      }
    }
  ```

  **结果**

  ```java
  == comparison : true
  == comparison : true
  Using equals method : true
  == comparison : false
  Using equals method : true
  ```

- 问题：如果去掉了`main`方法的`static`修饰符会怎样？

  - 答案：程序能正常编译。运行时会抛出`NoSuchMethodError`异常

- 问题：为什么`oracle type4`驱动被称作瘦驱动？

  - 答案：`oracle`提供了一个`type4 JDBC`驱动被称为瘦驱动，是因为这个驱动包含了一个`Oracle`自己完全用`	Java`实现的一个`TCP/IP`的`Net8`的实现，因此它是平台独立的，可以在运行时由浏览器下载，不依赖任何客户端的`oracle`实现。客户端连接字符串用的是`TCP/IP`的地址窗口，而不是数据库名的`tnsname`

- 问题：介绍一下`finalize`方法

  - 答案：`final`：常量声明，`finally`：处理异常，`finalize`：帮助进行垃圾回收
    接口里声明的变量默认是`final`，`final`类无法继承，也就是没有子类。这么做是出于基础类型的安全考虑，比如`String`和`Interger`。这样也使得编译器进行一些优化，更容易保证线程的安全性。`final`方法无法重写，`final`变量的值不能改变。`finalize()`方法在一个对象被销毁和回收前会被调用。`finally`通常用于异常处理，不管有没有异常被抛出都会被执行到。比如，关闭连接通常放到`finally`块中完成

- 问题：什么是`Java API`?

  - 答案：`Java API`是大量软件组件的集合，提供了大量有用的功能，比如`GUI`组件

- 问题：`GregorianCalendar`类是什么东西？

  - 答案：`GregorianCalendar`提供了西方传统日历的支持

- 问题：`ResourceBundle`类是什么？

  - 答案：`ResourceBundle`用来存储指定语言环境的资源，应用程序可以根据运行时语言环境来加载这些资源，从而提供不同语言的提示

- 问题：为什么`Java`里面没有全局变量？

  - 答案：全局变量是全局可见的，`Java`不支持全局可见的变量，因为全局变量破坏了引用透明性原则。全局变量导致了命名空间的冲突

- 问题：如何将`String`类型转化成`Number`类型？

  - 答案：`Integer`类的`valueOf`方法可以将`String`转成`Number`。下面是代码示例：

    ```java
    String numString = "1000";
    int id = Intrger.valueOf(numString).intValue();
    ```

- 问题：`SimpleTImeZone`类是什么

  - 答案：`SimpleTimeZone`提供公历日期支持

- 问题：`While`循环和`do / while`循环有什么不同？

  - 答案：`while`结构在循环的开始就判断下一个迭代是否应该继续。`do / while`结构是在循环的结尾来判断是否将继续下一轮迭代。`do / while`结构至少会执行一次循环体

- 问题：`locale`类是什么？

  - 答案：`Locale`类用来根据语言环境来动态调整程序的输出

- 问题：面对对象变成的原则什么？

  - 答案：主要3点，继承，多态，封装

- 问题：继承，多态和封装是什么？

  - 答案：简单来说，多态是指一个名字多种实现，多态使得一个实体通过一个通用的方式来实现不同的操作。具体的操作是由实际的实现来决定的，多态在`Java`里有三种表现方式：方法重载通过继承实现方法重写通过`Java`接口进行方法重写

- 问题：介绍下继承的原则？

  - 答案：继承使得一个对象可以获取另一个对象的属性。使用继承可以让已经测试完备的功能得以复用，并且可以一次修改，所有继承的地方都同时生效

- 问题：什么是隐式的类型转换？

  - 答案：隐式的类型转换就是简单的一个类型赋值给另一个类型，没有显示的告诉编辑器发生了转化，并不是所有的类型都支持隐式的类型转换,隐式转化有叫自动类型转换。由系统自动完成的类型转换

    从存储范围小的类型到存储范围大的类型

    ```java
    byte -> short(char) -> int -> long -> float        -> double
    int d = 3;
    double n = d;
    ```

- 问题：什么是显式类型转换？

  - 答案：显式的类型转换是明确告诉了编译器来进行对象的转换，显式类型转换也叫强制类型转换。

    从存储范围大的类型到存储范围小的类型。具体规则为：		

    ```java
    double -> float -> long -> int -> short(char) -> byte
    ```

    语法格式为：(转换到的类型)需要转换的值示例代码：

    ```java
    double d = 3.10;
    int n = (int)d;
    ```

- 问题：`sizeof`是`Java`的关键字？

  - 答案：不是

- 问题：`natlve`方法是什么？

  - 答案：`natlve`方法是非`Java`代码实现的方法

- 问题：在`System.out.println()`里面的`System,out,println`分别是什么？

  - 答案：
    - `System`是系统提供的预定义的`final`类
    - `out`是一个`PrintStream`对象
    - `println`是`out`对象里面一个重载的方法

- 问题：什么是`Java`虚拟机？

  - 答案：`Java虚拟机是能够移植到不同硬件平台上的软件系统`

- 问题：类型向下转换是什么？

  - 答案：向下转换是指由一个通用类型转换成一个具体的类型，在继承结构上向下运行

- 问题：`Java`的访问修饰符是什么？

  - 答案：访问权限修饰符是表明类成员的访问权限的关键字。使用这些关键字来限定程序的方法或者变量的访问权限。它们包含：
    - `public`所有类都可以访问`protected`同一个包内以及所有子类都可以访问
    - `private`只有归属的类才能默认访问，归属类及相同包的子类可以访问

- 问题：所有类的父类是什么？

  - 答案：object

- 问题：所有`Java`的基本类型有那些？

  - 答案：`byte, char, short, int, long, float, double, boolean`

- 问题：静态类型有什么特点？

  - 答案：静态变量和类绑定在一起的，而不是类的实例对象。每一个实例对象都共享一份静态变量，也就是说，一个类的静态变量只有一份，不管它有多少个对象，类变量或者说静态变量是通过`static`这个关键字来声明的。类变量通常被用作常理。静态变量通常通过类名字来进行访问，当程序运行的时候，这个变量就会创建直到程序结束后才会被销毁，类变量的作用域和实例变量的一样的，它的初始值和成员变量也是一样的，当变量没被初始化的时候根据它的数据类型。会有一个默认值。类似的，静态方法是属于类的方法，而不是类对象，它的调用并不作用于对类对象，也不需要创建任何的实例。静态方法本身就是`final`的，因为重写只会发生在类实例上，静态方法是和类绑定在一起的，不是对象，父类的静态方法会被子类的静态方法屏蔽，只要原来方法没有声明为`final`，非静态方法不能重写静态方法，也就是说，你不能在子类中把一个静态方法改成实例方法
  - 非静态变量在每一个对象实例上都有单独的一份值

- 问题：`&`操作符和`&&`操作符有什么去吧

  - 答案：当一个`&`表达式在求值的时候，两个操作数都会被求值，`&&`更像是一个操作符的快捷方法。当一个`&&`表达式求值的时候，先计算第一个操作数，如果它返回`true`才会计算操作第二个操作数，如果第一个操作数取值为`false`，第二个操作数就不会被求值

- 问题：`Java`是如何处理整形的溢出和下溢的？

  - 答案：`Java`根据类型的大小，将计算结果中的对应低阶字节存储到对应的值里面

- 问题：`public static void`写成`static public void`会怎样？

  - 答案：程序正常编译运行

- 问题：声明变量和定义变量有什么不同？

  - 答案：声明变量我们只提供变量的类型和名字，并没有进行初始化，定义包括声明和初始化两个阶段`String s` 只是变量声明，`String s = new String('bob')`或者`String s = 'bob'`是变量定义

- 问题：`Java`支持哪种参数传递类型？

  - 答案：`Java`参数都是进行传值，对于对象而言，传递的值是对象的引用，也就是说原始引用和参数引用的那个拷贝，都是指向同一个对象

- 问题：对象封装的原则是什么？

  - 答案：封装是将数据及操作数据的代码绑定到一个独立的单元。这样保障了数据的安全，防止外部代码的数据使用，对象允许程序和数据进行封装，以减少潜在的干涉，对封装的另一个理解是作为数据及代码的保护层，防止保护层外代码的随意访问

- 问题：你怎么理解变量？

  - 答案：变量是一块命名的内存区域，以便程序进行访问，变量用来存储数据，随着程序的执行，存储的数据也可能跟着改变

- 问题：数值提升是什么？

  - 答案：数值提升是指数据从一个较小的数据类型转换成为一个更大的数据类型，以便进行整形或者浮点型运算。在数值提升的过程中，`byte,char,short`值会被转化成`int`类型，需要的时候`int`类型也可能被提升为`long`.`long`和`float`则有可能会被转换成为`double`类型。

- 问题：`java`的类型转化是什么？

  - 答案：从一个数据类型转换成另一个数据类型转换，`Java`有两种类型转换方式，一个是显示类型转换，一个是隐式的

- 问题：`main`方法的参数里面，字符串数组的第一个参数是什么？

  - 答案：数组是空的，没有任何元素。不像`C` 和`C++`，第一个元素是默认程序名。如果命令行没有提供任何参数的话，`main`方法中的`String`数组为空，但不是`null`

- 问题：怎么判断数组是`null`还是为空？

  - 答案：输出`array.length`的值，如果问为`0`，说明数组为空，如果是`null`的话，会抛出空指针异常

- 问题：程序中可以允许多个类同时拥有都有`main`方法吗？

  - 答案：可以。当程序运行的时候，我们会指定运行的类名，`JVM`只会在你指定的类中查找`main`方法，因此多个类拥有`main`方法并不存在命名冲突问题

- 问题：静态变量在什么时候加载？编译期还是运行期？静态代码块加载的时机昵？

  - 答案：当类加载器将类加载带`JVM`中的时候就会创建静态变量，这跟对象是否创建无关，静态变量加载的时候就会分配内存空间。静态代码块的代码只会在类第一次初始化的时候执行一次，一个类可以有多个静态代码块，它并不是类的成员，也没有返回值，并且不能直接调用，静态代码块不能包含`this`或`super`它们通常被用初始化静态变量

- 问题：一个类能拥有多个`main`方法吗？

  - 答案：可以，但只能有一个`main`拥有以下签名，否则程序将无法通过编译，编译器会警告你`main`方法已经存在

- 问题：简单介绍下`JVM`是如何工作的？

  - 答案：   `JVM`是一台抽象的计算机，就像真实的计算机那样，它们会将`.java`文件编译成`.class`文件（`.class`文件就是字节码文件），然后用它的解释器来加载字节码

- 问题：如何原地交换两个变量的值？

  - 答案：先把两个值相加赋值给第一个变量，然后用得到的结果减去第二个变量，赋值给第二个变量，再用第一个变量减去第二个变量，同时赋值给第一个变量，代码如下：

  ```java
    public class	
  ```

  - 使用异或操作也可以交换，第一个方法可能还会引起溢出，异或的方法取下

    - ```java
      int a = 5, b = 10;
      a = a + b;
      b = a - b;
      a = a - b ;
      ```

- 问题：什么是数据的封装？

  - 答案：数据封装的一种方式是在类中创建`set`和`get`方法来访问对象的数据变量。一般来说变量是`private`的，而`get`和`set`方法是`public`的。封装还可以用来存储数据时进行数据验证，或者对数据进行计算，或者用作自省（比如在`struts`中使用`javabean`）。把数据和功能封装到一个独立结构中称为数据封装，封装其实就是把数据和关联的操作方法封装到一个独立的单元中，这样使用关联的这些方法才能对数据进行访问操作。封装提供的是数据安全性，它其实就是一种隐藏数据的方式

- 问题：什么是反射`API`？ 它是如何实现的？

  - 答案：反射是指在运行时能查看一个类的状态及特征，并能进行动态管理的功能。这些功能是通过一些内建类的反射`API`提供的，比如`Class、Method、Field、Constructors`等，使用的例子：使用`Java`反射`API`的`getName`方法可以获取到类名

- 问题：`JVM`自身会维护缓存吗，是不是在堆中进行对象分配，操作系统的堆还是`JVM`自己管理的堆，为什么？

  - 答案：是的，`JVM`自身会管理缓存，它在堆中创建对象，然后在栈中引用这些对象

- 问题：虚拟缓存是什么？

  - 答案：虚拟缓存又叫延伸缓存，实际上并不存在真实的物理缓存

- 问题：方法可以同时即是`static`又是`synchronized`的吗？

  - 答案：可以，如果这样做的话，`JVM`会获取到和这个对象关联的`java.lang.Class`实例上的锁，这样做等于：``

- 问题：`String`和`StringTokenizer`的区别是什么？

  - 答案：

    - StringTokenizer是一个用来分割字符串的工具类

      ```java
      StringTokenizer st = new StringTokenizer("Hello World")
      while(st.hasMoreTokens()){
      	System.out.println(st.nextToken())
      }
      ```

      输出：

      ```
      Hello
      World
      ```

- 问题：`transient`变量有什么特点？

  - 答案：`transient`变量不会进行序列化，例如一个实现`Serializable`接口的类在序列化到`ObjectStream`的时候，`transient`类型的变量不会被写入流中，同时，反序列化回来的时候，对应变量的值为`null`

- 问题：哪些容器使用`Borde`布局作为它们的默认布局？

  - 答案：`Window 、Frame 、 Dialog`

- 问题：理解什么是同步？

  - 答案：同步用来控制共享资源在多个线程间的访问，以保证同一时间内只有一个线程能访问到这个资源，在非同步保护的多线程程序里面，一个线程正在修改一个共享变量的时候，可以有另一个线程也在使用或者更新它的值，同步避免了脏数据的产生

    对方法进行同步：

    ```javas
    public synchronized void Method1(){
      // Appropriate method-related code
    }
    ```

    在方法内部对代码进行同步：

    ```java
    public myFunction(){
      synchronized(this){
        //synchronized code here
      }
    }
    ```

  ​

  ​